# üöÄ Enhanced PSP Router - Complete Implementation

## üéØ Overview

The Enhanced PSP Router is a sophisticated payment service provider routing system that combines **LLM-based decision making**, **multi-armed bandit learning**, and **vector memory** to optimize payment routing decisions in real-time.

## ‚ú® Key Features

### üß† **LLM-Powered Routing**
- **Intelligent Decision Making**: Uses GPT-4 with structured JSON responses
- **Context-Aware**: Considers transaction context, merchant preferences, and historical data
- **Tool Integration**: Can call external APIs for real-time health and fee data
- **Fallback Safety**: Graceful degradation to deterministic scoring when LLM is unavailable

### üé∞ **Multi-Armed Bandit Learning**
- **Epsilon-Greedy Algorithm**: Balances exploration vs exploitation (configurable epsilon)
- **Thompson Sampling**: Bayesian approach for optimal arm selection
- **Segment-Based Learning**: Different learning models per merchant/currency/scheme combination
- **Real-Time Updates**: Continuous learning from transaction outcomes

### üß† **Vector Memory System**
- **Semantic Search**: pgvector-powered similarity search for routing lessons
- **Embedding Storage**: OpenAI embeddings for contextual memory
- **Lesson Learning**: Automatic capture and retrieval of routing insights
- **Historical Context**: Leverages past decisions for better routing

### üìä **Comprehensive Monitoring**
- **Structured Logging**: Detailed logging with Microsoft.Extensions.Logging
- **Performance Metrics**: Processing time, success rates, fee optimization
- **Audit Trail**: Complete decision history with reasoning
- **Error Tracking**: Comprehensive error handling and reporting

## üèó Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Transaction   ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   PSP Router     ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   Decision      ‚îÇ
‚îÇ   Input         ‚îÇ    ‚îÇ                  ‚îÇ    ‚îÇ   Output        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚ñº
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   Learning       ‚îÇ
                    ‚îÇ   Components     ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚ñº                   ‚ñº
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ   Bandit    ‚îÇ    ‚îÇ   Vector    ‚îÇ
            ‚îÇ   Learning  ‚îÇ    ‚îÇ   Memory    ‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üöÄ Quick Start

### Prerequisites
- .NET 8.0 SDK
- PostgreSQL with pgvector extension
- OpenAI API key

### Environment Setup
```bash
export OPENAI_API_KEY=sk-your-openai-key
export PGVECTOR_CONNSTR="Host=localhost;Username=postgres;Password=postgres;Database=psp_router"
```

### Database Setup
```sql
CREATE EXTENSION IF NOT EXISTS vector;
```

### Run the Application
```bash
dotnet run
```

## üìã Usage Examples

### Basic Routing
```csharp
var router = new PspRouter(chatClient, healthProvider, feeProvider, tools, bandit, memory, logger);
var decision = await router.DecideAsync(context, cancellationToken);
```

### Learning from Outcomes
```csharp
var outcome = new TransactionOutcome(/* transaction results */);
router.UpdateReward(decision, outcome);
```

### Enhanced Example
```csharp
await EnhancedExample.RunAsync(); // Demonstrates full learning cycle
```

## üîß Configuration

### Bandit Learning
```csharp
// Epsilon-Greedy with 10% exploration
var bandit = new EpsilonGreedyBandit(epsilon: 0.1);

// Thompson Sampling for Bayesian approach
var bandit = new ThompsonSamplingBandit();
```

### LLM Configuration
```csharp
var chatClient = new OpenAIChatClient(apiKey, model: "gpt-4.1");
```

### Memory Configuration
```csharp
var memory = new PgVectorMemory(connectionString, table: "psp_lessons");
```

## üìä Decision Factors

The system considers multiple factors in routing decisions:

1. **Compliance** (SCA/3DS requirements)
2. **Authorization Success Rates** (historical performance)
3. **Fee Optimization** (minimize transaction costs)
4. **Merchant Preferences** (configured preferences)
5. **Historical Performance** (vector memory insights)
6. **Real-time Health** (PSP availability and latency)

## üéØ Reward Calculation

The learning system uses a sophisticated reward function:

```csharp
reward = baseAuthReward - feePenalty + speedBonus - riskPenalty
```

- **Base Reward**: +1.0 for successful authorization, 0.0 for decline
- **Fee Penalty**: Normalized fee amount as percentage of transaction
- **Speed Bonus**: +0.1 for processing under 1 second
- **Risk Penalty**: -0.2 for high-risk transactions (>50 risk score)

## üîç Monitoring & Observability

### Logging Levels
- **Information**: Routing decisions, learning updates
- **Warning**: Fallback scenarios, degraded performance
- **Error**: LLM failures, database issues, parsing errors
- **Debug**: Detailed decision reasoning, memory operations

### Key Metrics
- **Authorization Success Rate**: Per PSP, per segment
- **Average Processing Time**: Response time optimization
- **Fee Optimization**: Cost reduction over time
- **Learning Convergence**: Bandit algorithm performance

## üõ° Security & Compliance

### Data Protection
- **No PII to LLM**: Only BIN/scheme/aggregates sent to AI
- **Audit Trail**: Complete decision history
- **Secure Storage**: Encrypted database connections

### Compliance Features
- **SCA Enforcement**: Automatic 3DS when required
- **Regulatory Compliance**: Built-in compliance checks
- **Risk Management**: Integrated risk scoring

## üîÑ Learning Loop

1. **Route Decision**: LLM or bandit selects PSP
2. **Transaction Processing**: PSP processes payment
3. **Outcome Capture**: Success/failure, fees, timing
4. **Reward Calculation**: Multi-factor reward computation
5. **Learning Update**: Bandit algorithm updates
6. **Memory Storage**: Lessons stored in vector database
7. **Continuous Improvement**: Better decisions over time

## üöÄ Production Deployment

### Scaling Considerations
- **Horizontal Scaling**: Stateless design supports multiple instances
- **Database Optimization**: Proper indexing for vector searches
- **Caching**: Consider Redis for frequently accessed data
- **Load Balancing**: Distribute traffic across PSP endpoints

### Monitoring Setup
- **Application Insights**: Azure monitoring integration
- **Prometheus/Grafana**: Custom metrics dashboard
- **Alerting**: Set up alerts for critical failures
- **Health Checks**: Endpoint monitoring for all PSPs

## üîß Customization

### Adding New PSPs
1. Update `CapabilityMatrix.Supports()` method
2. Implement health and fee providers
3. Add PSP-specific logic to reward calculation
4. Update system prompts with new PSP characteristics

### Custom Reward Functions
```csharp
private static double CalculateCustomReward(TransactionOutcome outcome)
{
    // Your custom reward logic here
    return customReward;
}
```

### Enhanced Memory Integration
```csharp
private async Task<List<string>> GetRelevantLessonsAsync(RouteContext ctx, CancellationToken ct)
{
    // Implement full embedding-based search
    var queryEmbedding = await _embeddings.EmbedAsync(query, ct);
    var results = await _memory.SearchAsync(queryEmbedding, k: 5, ct);
    return results.Select(r => r.text).ToList();
}
```

## üìà Performance Optimization

### Caching Strategy
- **PSP Health**: Cache health status for 30 seconds
- **Fee Tables**: Cache fee data for 5 minutes
- **Memory Results**: Cache vector search results
- **Bandit State**: In-memory bandit statistics

### Database Optimization
```sql
-- Optimize vector search performance
CREATE INDEX CONCURRENTLY psp_lessons_embedding_idx 
ON psp_lessons USING ivfflat (embedding vector_cosine_ops) 
WITH (lists = 100);
```

## üß™ Testing

### Unit Tests
```csharp
[Test]
public async Task Router_ShouldFallbackToDeterministic_WhenLLMFails()
{
    // Test fallback behavior
}
```

### Integration Tests
```csharp
[Test]
public async Task Learning_ShouldImproveOverTime()
{
    // Test learning convergence
}
```

## üìö API Reference

### Core Classes

#### `PspRouter`
Main routing engine with LLM and bandit integration.

#### `EpsilonGreedyBandit`
Multi-armed bandit with epsilon-greedy exploration strategy.

#### `ThompsonSamplingBandit`
Bayesian multi-armed bandit with Thompson sampling.

#### `PgVectorMemory`
Vector database integration for semantic memory.

#### `OpenAIChatClient`
LLM integration with tool calling support.

### Key Methods

#### `DecideAsync(RouteContext, CancellationToken)`
Makes routing decision using LLM or fallback logic.

#### `UpdateReward(RouteDecision, TransactionOutcome)`
Updates bandit learning with transaction outcome.

#### `AddAsync(string, string, Dictionary, float[], CancellationToken)`
Adds lesson to vector memory.

#### `SearchAsync(float[], int, CancellationToken)`
Searches vector memory for relevant lessons.

## ü§ù Contributing

1. Fork the repository
2. Create feature branch
3. Add tests for new functionality
4. Ensure all tests pass
5. Submit pull request

## üìÑ License

This project is licensed under the MIT License - see the LICENSE file for details.

## üÜò Support

For questions and support:
- Create an issue in the repository
- Check the documentation
- Review the example implementations

---

**Happy Routing! üéØ**

The Enhanced PSP Router provides a production-ready foundation for intelligent payment routing with continuous learning and optimization.
